#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
XODR到OBJ转换器 v3.1.0
基于libOpenDRIVE实现的高级OpenDRIVE到OBJ格式转换器

改进特性:
- 正确的车道边界计算
- 基于s-t坐标系的表面点计算
- 车道级别网格生成
- 法向量和纹理坐标支持
- 材质和分组管理
- 参考libOpenDRIVE架构设计

作者: ShpToOpenDrive项目组
版本: 3.1.0
日期: 2024
"""

import xml.etree.ElementTree as ET
import math
import os
import logging
from typing import List, Tuple, Optional, Dict, Any, Set
from pathlib import Path

# 配置日志
# 确保logs目录存在
log_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'logs')
os.makedirs(log_dir, exist_ok=True)

# 配置日志输出到文件
log_file = os.path.join(log_dir, 'xodr_to_obj_converter.log')
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file, encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class Vec3D:
    """3D向量类，参考libOpenDRIVE实现"""
    
    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0):
        self.x = x
        self.y = y
        self.z = z
    
    def __add__(self, other: 'Vec3D') -> 'Vec3D':
        return Vec3D(self.x + other.x, self.y + other.y, self.z + other.z)
    
    def __sub__(self, other: 'Vec3D') -> 'Vec3D':
        return Vec3D(self.x - other.x, self.y - other.y, self.z - other.z)
    
    def __mul__(self, scalar: float) -> 'Vec3D':
        return Vec3D(self.x * scalar, self.y * scalar, self.z * scalar)
    
    def dot(self, other: 'Vec3D') -> float:
        return self.x * other.x + self.y * other.y + self.z * other.z
    
    def cross(self, other: 'Vec3D') -> 'Vec3D':
        return Vec3D(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )
    
    def length(self) -> float:
        return math.sqrt(self.x * self.x + self.y * self.y + self.z * self.z)
    
    def normalize(self) -> 'Vec3D':
        length = self.length()
        if length > 0:
            return Vec3D(self.x / length, self.y / length, self.z / length)
        return Vec3D(0, 0, 0)
    
    def __str__(self) -> str:
        return f"({self.x:.6f}, {self.y:.6f}, {self.z:.6f})"


class Vec2D:
    """2D向量类，用于纹理坐标"""
    
    def __init__(self, u: float = 0.0, v: float = 0.0):
        self.u = u
        self.v = v
    
    def __str__(self) -> str:
        return f"({self.u:.6f}, {self.v:.6f})"


class Mesh3D:
    """3D网格类，参考libOpenDRIVE的Mesh3D结构"""
    
    def __init__(self):
        self.vertices: List[Vec3D] = []
        self.normals: List[Vec3D] = []
        self.st_coordinates: List[Vec2D] = []  # 纹理坐标
        self.indices: List[int] = []
        self.material_groups: Dict[str, List[int]] = {}  # 材质分组
    
    def add_mesh(self, other: 'Mesh3D', material_name: str = None):
        """合并另一个网格到当前网格"""
        vertex_offset = len(self.vertices)
        
        # 添加顶点、法向量和纹理坐标
        self.vertices.extend(other.vertices)
        self.normals.extend(other.normals)
        self.st_coordinates.extend(other.st_coordinates)
        
        # 添加索引（需要偏移）
        offset_indices = [idx + vertex_offset for idx in other.indices]
        
        if material_name is not None:
            # 使用指定的材质名
            if material_name not in self.material_groups:
                self.material_groups[material_name] = []
            
            # 记录这个材质组的面索引范围
            start_face = len(self.indices) // 3
            self.indices.extend(offset_indices)
            end_face = len(self.indices) // 3
            
            self.material_groups[material_name].extend(range(start_face, end_face))
        else:
            # 保持原有的材质分组
            face_offset = len(self.indices) // 3
            self.indices.extend(offset_indices)
            
            # 复制原网格的材质分组，并调整面索引
            for mat_name, face_indices in other.material_groups.items():
                if mat_name not in self.material_groups:
                    self.material_groups[mat_name] = []
                
                # 调整面索引偏移
                adjusted_indices = [face_idx + face_offset for face_idx in face_indices]
                self.material_groups[mat_name].extend(adjusted_indices)
    
    def get_obj(self, mtl_filename: str = "road_materials.mtl") -> str:
        """生成OBJ格式字符串，参考libOpenDRIVE实现"""
        obj_content = []
        
        # 添加注释
        obj_content.append("# Generated by XODR to OBJ Converter v3.1.0")
        obj_content.append("# Based on libOpenDRIVE implementation")
        obj_content.append("")
        
        # 添加MTL文件引用
        obj_content.append(f"mtllib {mtl_filename}")
        obj_content.append("")
        
        # 添加顶点
        for vertex in self.vertices:
            obj_content.append(f"v {vertex.x:.6f} {vertex.y:.6f} {vertex.z:.6f}")
        
        obj_content.append("")
        
        # 添加法向量
        for normal in self.normals:
            obj_content.append(f"vn {normal.x:.6f} {normal.y:.6f} {normal.z:.6f}")
        
        obj_content.append("")
        
        # 添加纹理坐标
        for st_coord in self.st_coordinates:
            obj_content.append(f"vt {st_coord.u:.6f} {st_coord.v:.6f}")
        
        obj_content.append("")
        
        # 按材质分组添加面
        if self.material_groups:
            for material_name, face_indices in self.material_groups.items():
                obj_content.append(f"usemtl {material_name}")
                obj_content.append(f"g {material_name}_group")
                
                for face_idx in face_indices:
                    start_idx = face_idx * 3
                    if start_idx + 2 < len(self.indices):
                        # OBJ索引从1开始
                        v1 = self.indices[start_idx] + 1
                        v2 = self.indices[start_idx + 1] + 1
                        v3 = self.indices[start_idx + 2] + 1
                        
                        # 包含顶点、纹理坐标和法向量
                        obj_content.append(f"f {v1}/{v1}/{v1} {v2}/{v2}/{v2} {v3}/{v3}/{v3}")
                
                obj_content.append("")
        else:
            # 如果没有材质分组，直接添加所有面
            obj_content.append("usemtl default_material")
            obj_content.append("g default_group")
            
            for i in range(0, len(self.indices), 3):
                if i + 2 < len(self.indices):
                    # OBJ索引从1开始
                    v1 = self.indices[i] + 1
                    v2 = self.indices[i + 1] + 1
                    v3 = self.indices[i + 2] + 1
                    
                    # 包含顶点、纹理坐标和法向量
                    obj_content.append(f"f {v1}/{v1}/{v1} {v2}/{v2}/{v2} {v3}/{v3}/{v3}")
        
        return "\n".join(obj_content)


class Lane:
    """车道类，简化的libOpenDRIVE Lane实现"""
    
    def __init__(self, lane_id: int, lane_type: str = "driving"):
        self.id = lane_id
        self.type = lane_type
        self.width_entries: List[Dict] = []  # 宽度条目
        self.level = False  # 是否为水平车道
    
    def add_width_entry(self, s_offset: float, a: float, b: float = 0.0, c: float = 0.0, d: float = 0.0):
        """添加宽度条目"""
        self.width_entries.append({
            's_offset': s_offset,
            'a': a,
            'b': b,
            'c': c,
            'd': d
        })
    
    def get_width(self, s: float) -> float:
        """获取指定s位置的车道宽度"""
        if not self.width_entries:
            return 3.5  # 默认宽度
        
        # 找到适用的宽度条目
        applicable_entry = None
        for entry in self.width_entries:
            if s >= entry['s_offset']:
                applicable_entry = entry
            else:
                break
        
        if applicable_entry is None:
            return 3.5
        
        # 计算相对于条目起点的距离
        ds = s - applicable_entry['s_offset']
        
        # 三次多项式计算宽度
        width = (applicable_entry['a'] + 
                applicable_entry['b'] * ds + 
                applicable_entry['c'] * ds * ds + 
                applicable_entry['d'] * ds * ds * ds)
        
        return abs(width)  # 确保宽度为正值


class XODRToOBJConverter:
    """XODR到OBJ转换器，基于libOpenDRIVE实现"""
    
    def __init__(self, resolution: float = 0.5, with_lane_height: bool = False, 
                 with_road_objects: bool = False, eps: float = 0.1, verbose: bool = False,
                 coordinate_offset: tuple = (0.0, 0.0)):
        """
        初始化转换器
        
        Args:
            resolution: 采样分辨率（米）
            with_lane_height: 是否包含车道高度
            with_road_objects: 是否包含道路对象
            eps: 精度参数
            verbose: 是否输出详细日志
            coordinate_offset: 坐标偏移量 (x_offset, y_offset)
        """
        self.resolution = resolution
        self.with_lane_height = with_lane_height
        self.with_road_objects = with_road_objects
        self.eps = eps
        self.verbose = verbose
        self.coordinate_offset = coordinate_offset
    
    def convert(self, xodr_file: str, obj_file: str) -> bool:
        """
        转换XODR文件到OBJ格式
        
        Args:
            xodr_file: 输入XODR文件路径
            obj_file: 输出OBJ文件路径
            
        Returns:
            转换是否成功
        """
        try:
            if self.verbose:
                logger.info(f"开始转换: {xodr_file} -> {obj_file}")
                logger.info(f"分辨率: {self.resolution}m, 精度: {self.eps}")
            
            # 生成道路网络网格
            road_network_mesh = self.get_road_network_mesh(xodr_file)
            
            if road_network_mesh is None:
                if self.verbose:
                    logger.error("错误: 无法生成道路网络网格")
                return False
            
            # 导出MTL材质文件
            mtl_file = obj_file.replace('.obj', '.mtl')
            mtl_filename = os.path.basename(mtl_file)
            self._export_materials(mtl_file, road_network_mesh)
            
            # 导出OBJ文件
            obj_content = road_network_mesh.get_obj(mtl_filename)
            
            with open(obj_file, 'w', encoding='utf-8') as f:
                f.write(obj_content)
            
            if self.verbose:
                logger.info(f"转换完成: {obj_file}")
                logger.info(f"顶点数: {len(road_network_mesh.vertices)}")
                logger.info(f"面数: {len(road_network_mesh.indices) // 3}")
                logger.info(f"法向量数: {len(road_network_mesh.normals)}")
                logger.info(f"纹理坐标数: {len(road_network_mesh.st_coordinates)}")
            
            return True
            
        except Exception as e:
            if self.verbose:
                logger.error(f"转换失败: {str(e)}")
            return False
    
    def get_road_network_mesh(self, xodr_file: str) -> Optional[Mesh3D]:
        """
        获取道路网络网格，参考libOpenDRIVE实现
        
        Args:
            xodr_file: XODR文件路径
            
        Returns:
            道路网络网格对象
        """
        try:
            tree = ET.parse(xodr_file)
            root = tree.getroot()
            
            road_network_mesh = Mesh3D()
            
            # 遍历所有道路
            roads = root.findall('.//road')
            for road in roads:
                road_mesh = self._generate_road_mesh_improved(road)
                if road_mesh:
                    road_network_mesh.add_mesh(road_mesh)
            
            return road_network_mesh
            
        except Exception as e:
            if self.verbose:
                logger.error(f"生成道路网络网格失败: {str(e)}")
            return None
    
    def _generate_road_mesh_improved(self, road_element) -> Optional[Mesh3D]:
        """
        生成改进的道路网格，基于libOpenDRIVE方法
        
        Args:
            road_element: 道路XML元素
            
        Returns:
            道路网格对象
        """
        try:
            road_mesh = Mesh3D()
            
            # 获取道路基本信息
            road_id = road_element.get('id', 'unknown')
            road_length = float(road_element.get('length', 0))
            
            if self.verbose:
                logger.info(f"处理道路: {road_id}, 长度: {road_length:.2f}m")
            
            # 获取平面视图
            plan_view = road_element.find('planView')
            if plan_view is None:
                return None
            
            # 获取车道信息
            lanes = road_element.find('lanes')
            if lanes is not None:
                lanes_mesh = self._generate_lanes_mesh_improved(lanes, plan_view, road_length)
                if lanes_mesh:
                    # 直接将车道网格添加到道路网格中，保持独立的材质
                    road_mesh.add_mesh(lanes_mesh)
            
            return road_mesh
            
        except Exception as e:
            if self.verbose:
                logger.error(f"生成道路网格失败: {str(e)}")
            return None
    
    def _generate_lanes_mesh_improved(self, lanes_element, plan_view, road_length: float) -> Optional[Mesh3D]:
        """
        生成改进的车道网格，参考libOpenDRIVE实现
        支持多车道面和正确的车道边界计算
        
        Args:
            lanes_element: 车道XML元素
            plan_view: 平面视图XML元素
            road_length: 道路长度
            
        Returns:
            车道网格对象
        """
        try:
            lanes_mesh = Mesh3D()
            
            # 获取参考线几何
            ref_line_points = self._get_reference_line_points(plan_view, road_length)
            
            if len(ref_line_points) < 2:
                if self.verbose:
                    logger.warning(f"参考线点数不足: {len(ref_line_points)}")
                return None
            
            # 处理车道段
            lane_sections = lanes_element.findall('laneSection')
            
            for i, lane_section in enumerate(lane_sections):
                s_start = float(lane_section.get('s', 0))
                
                # 解析所有车道并按ID排序
                all_lanes = self._parse_lane_section(lane_section)
                
                # 计算车道边界（outer_border）
                lane_boundaries = self._calculate_lane_boundaries(all_lanes, ref_line_points, s_start, road_length)
                
                # 为每个车道生成独立网格
                lane_count = 0
                for lane_id, lane_data in all_lanes.items():
                    if lane_id == 0:  # 跳过中心车道
                        continue
                        
                    lane_mesh = self._generate_individual_lane_mesh(
                        lane_data, lane_boundaries, lane_id, ref_line_points, s_start, road_length
                    )
                    
                    if lane_mesh:
                        material_name = f"lane_{lane_id}" if lane_id > 0 else f"lane_neg_{abs(lane_id)}"
                        # 车道网格生成成功
                        lanes_mesh.add_mesh(lane_mesh)
                        lane_count += 1
                
                if self.verbose:
                    logger.info(f"车道段 {i+1} 处理完成，生成了 {lane_count} 个车道网格")
            
            if self.verbose:
                logger.info(f"所有车道段处理完成，总顶点数: {len(lanes_mesh.vertices)}")
            return lanes_mesh
            
        except Exception as e:
            if self.verbose:
                logger.error(f"生成车道网格失败: {str(e)}")
            return None
    
    def _parse_lane_section(self, lane_section) -> Dict[int, Dict]:
        """
        解析车道段，返回按ID排序的车道数据
        
        Args:
            lane_section: 车道段XML元素
            
        Returns:
            车道数据字典 {lane_id: {element: xml_element, lane: Lane_object}}
        """
        lanes_data = {}
        
        # 处理中心车道（ID=0）
        center_lane = lane_section.find('center')
        if center_lane is not None:
            center_lane_elem = center_lane.find('lane')
            if center_lane_elem is not None:
                lanes_data[0] = {
                    'element': center_lane_elem,
                    'lane': Lane(0, 'none')
                }
        
        # 处理左侧车道（正数ID）
        left_lanes = lane_section.find('left')
        if left_lanes is not None:
            for lane_elem in left_lanes.findall('lane'):
                lane_id = int(lane_elem.get('id', 0))
                lane = Lane(lane_id, lane_elem.get('type', 'driving'))
                
                # 解析车道宽度
                width_elements = lane_elem.findall('width')
                for width_elem in width_elements:
                    s_offset = float(width_elem.get('sOffset', 0))
                    a = float(width_elem.get('a', 3.5))
                    b = float(width_elem.get('b', 0))
                    c = float(width_elem.get('c', 0))
                    d = float(width_elem.get('d', 0))
                    lane.add_width_entry(s_offset, a, b, c, d)
                
                lanes_data[lane_id] = {
                    'element': lane_elem,
                    'lane': lane
                }
        
        # 处理右侧车道（负数ID）
        right_lanes = lane_section.find('right')
        if right_lanes is not None:
            for lane_elem in right_lanes.findall('lane'):
                lane_id = int(lane_elem.get('id', 0))
                lane = Lane(lane_id, lane_elem.get('type', 'driving'))
                
                # 解析车道宽度
                width_elements = lane_elem.findall('width')
                for width_elem in width_elements:
                    s_offset = float(width_elem.get('sOffset', 0))
                    a = float(width_elem.get('a', 3.5))
                    b = float(width_elem.get('b', 0))
                    c = float(width_elem.get('c', 0))
                    d = float(width_elem.get('d', 0))
                    lane.add_width_entry(s_offset, a, b, c, d)
                
                lanes_data[lane_id] = {
                    'element': lane_elem,
                    'lane': lane
                }
        
        return lanes_data
    
    def _get_reference_line_points(self, plan_view, road_length: float) -> List[Vec3D]:
        """
        获取参考线点列表
        
        Args:
            plan_view: 平面视图XML元素
            road_length: 道路长度
            
        Returns:
            参考线点列表
        """
        points = []
        current_s = 0.0
        current_pos = [0.0, 0.0]
        current_hdg = 0.0
        
        geometries = plan_view.findall('geometry')
        
        for geometry in geometries:
            s = float(geometry.get('s', 0))
            x = float(geometry.get('x', 0))
            y = float(geometry.get('y', 0))
            hdg = float(geometry.get('hdg', 0))
            length = float(geometry.get('length', 0))
            
            # 更新当前位置和方向
            current_pos = [x, y]
            current_hdg = hdg
            current_s = s
            
            # 根据几何类型生成点
            num_points = max(2, int(length / self.resolution) + 1)
            geometry_points = self._generate_geometry_points_advanced(
                geometry, current_pos, current_hdg, length, num_points
            )
            
            points.extend(geometry_points)
        
        return points
    
    def _calculate_lane_boundaries(self, lanes_data: Dict[int, Dict], ref_line_points: List[Vec3D], 
                                 s_start: float, road_length: float) -> Dict[int, List[Vec3D]]:
        """
        计算所有车道的边界线（outer_border），参考libOpenDRIVE算法
        
        Args:
            lanes_data: 车道数据字典
            ref_line_points: 参考线点列表
            s_start: 车道段起始s坐标
            road_length: 道路长度
            
        Returns:
            车道边界字典 {lane_id: [boundary_points]}
        """
        boundaries = {}
        num_points = len(ref_line_points)
        
        # 初始化中心车道边界（参考线）
        boundaries[0] = ref_line_points.copy()
        
        # 获取排序的车道ID
        sorted_lane_ids = sorted(lanes_data.keys())
        
        # 计算正数车道边界（左侧，累加宽度）
        positive_ids = [lid for lid in sorted_lane_ids if lid > 0]
        for lane_id in positive_ids:
            lane = lanes_data[lane_id]['lane']
            prev_lane_id = lane_id - 1
            
            if prev_lane_id in boundaries:
                boundary_points = []
                prev_boundary = boundaries[prev_lane_id]
                
                for i in range(num_points):
                    # 计算当前s坐标
                    s = s_start + (i / (num_points - 1)) * (road_length - s_start)
                    
                    # 获取车道宽度
                    lane_width = lane.get_width(s)
                    
                    # 计算切线方向
                    ref_point = ref_line_points[i]
                    if i < num_points - 1:
                        tangent = ref_line_points[i + 1] - ref_point
                    else:
                        tangent = ref_point - ref_line_points[i - 1]
                    
                    tangent = tangent.normalize()
                    
                    # 计算法向量（垂直于切线，指向左侧）
                    normal = Vec3D(-tangent.y, tangent.x, 0).normalize()
                    
                    # 累加宽度：当前边界 = 前一个边界 + 宽度 * 法向量
                    prev_point = prev_boundary[i]
                    new_point = prev_point + normal * lane_width
                    boundary_points.append(new_point)
                
                boundaries[lane_id] = boundary_points
        
        # 计算负数车道边界（右侧，累减宽度）
        negative_ids = [lid for lid in sorted_lane_ids if lid < 0]
        negative_ids.sort(reverse=True)  # 从-1开始向下
        
        for lane_id in negative_ids:
            lane = lanes_data[lane_id]['lane']
            prev_lane_id = lane_id + 1
            
            if prev_lane_id in boundaries:
                boundary_points = []
                prev_boundary = boundaries[prev_lane_id]
                
                for i in range(num_points):
                    # 计算当前s坐标
                    s = s_start + (i / (num_points - 1)) * (road_length - s_start)
                    
                    # 获取车道宽度
                    lane_width = lane.get_width(s)
                    
                    # 计算切线方向
                    ref_point = ref_line_points[i]
                    if i < num_points - 1:
                        tangent = ref_line_points[i + 1] - ref_point
                    else:
                        tangent = ref_point - ref_line_points[i - 1]
                    
                    tangent = tangent.normalize()
                    
                    # 计算法向量（垂直于切线，指向右侧）
                    normal = Vec3D(tangent.y, -tangent.x, 0).normalize()
                    
                    # 累减宽度：当前边界 = 前一个边界 + 宽度 * 法向量
                    prev_point = prev_boundary[i]
                    new_point = prev_point + normal * lane_width
                    boundary_points.append(new_point)
                
                boundaries[lane_id] = boundary_points
        
        return boundaries
    
    def _generate_individual_lane_mesh(self, lane_data: Dict, boundaries: Dict[int, List[Vec3D]], 
                                     lane_id: int, ref_line_points: List[Vec3D], 
                                     s_start: float, road_length: float) -> Optional[Mesh3D]:
        """
        为单个车道生成独立的网格面
        
        Args:
            lane_data: 车道数据
            boundaries: 车道边界字典
            lane_id: 车道ID
            ref_line_points: 参考线点列表
            s_start: 车道段起始s坐标
            road_length: 道路长度
            
        Returns:
            车道网格对象
        """
        try:
            mesh = Mesh3D()
            lane = lane_data['lane']
            
            # 获取车道的内外边界
            if lane_id > 0:  # 正数车道（左侧）
                outer_boundary = boundaries.get(lane_id, [])
                inner_boundary = boundaries.get(lane_id - 1, [])
            else:  # 负数车道（右侧）
                outer_boundary = boundaries.get(lane_id, [])
                inner_boundary = boundaries.get(lane_id + 1, [])
            
            if not outer_boundary or not inner_boundary:
                return None
            
            num_points = len(outer_boundary)
            
            # 添加顶点、法向量和纹理坐标
            for i in range(num_points):
                s = s_start + (i / (num_points - 1)) * (road_length - s_start)
                u = s / road_length
                
                # 添加外边界点（应用坐标偏移）
                outer_vertex = Vec3D(
                    outer_boundary[i].x - self.coordinate_offset[0],
                    outer_boundary[i].y - self.coordinate_offset[1],
                    outer_boundary[i].z
                )
                mesh.vertices.append(outer_vertex)
                mesh.normals.append(Vec3D(0, 0, 1))  # 向上法向量
                mesh.st_coordinates.append(Vec2D(u, 1.0))
                
                # 添加内边界点（应用坐标偏移）
                inner_vertex = Vec3D(
                    inner_boundary[i].x - self.coordinate_offset[0],
                    inner_boundary[i].y - self.coordinate_offset[1],
                    inner_boundary[i].z
                )
                mesh.vertices.append(inner_vertex)
                mesh.normals.append(Vec3D(0, 0, 1))  # 向上法向量
                mesh.st_coordinates.append(Vec2D(u, 0.0))
            
            # 生成三角形索引
            for i in range(num_points - 1):
                base_idx = i * 2
                
                # 根据车道ID确定面的方向
                if lane_id > 0:  # 正数车道，逆时针
                    mesh.indices.extend([
                        base_idx, base_idx + 1, base_idx + 2,
                        base_idx + 1, base_idx + 3, base_idx + 2
                    ])
                else:  # 负数车道，顺时针
                    mesh.indices.extend([
                        base_idx, base_idx + 2, base_idx + 1,
                        base_idx + 1, base_idx + 2, base_idx + 3
                    ])
            
            # 设置材质分组
            material_name = f"lane_{lane_id}" if lane_id > 0 else f"lane_neg_{abs(lane_id)}"
            num_faces = len(mesh.indices) // 3
            mesh.material_groups[material_name] = list(range(num_faces))
            
            return mesh
            
        except Exception as e:
            if self.verbose:
                logger.error(f"生成车道{lane_id}网格失败: {str(e)}")
            return None
    
    def _generate_geometry_points_advanced(self, geometry_element, start_pos: List[float], 
                                         hdg: float, length: float, num_points: int) -> List[Vec3D]:
        """
        生成几何体点列表（高级版本）
        
        Args:
            geometry_element: 几何体XML元素
            start_pos: 起始位置 [x, y]
            hdg: 起始航向角
            length: 几何体长度
            num_points: 生成点数
            
        Returns:
            3D点列表
        """
        # 检查几何体类型
        line_elem = geometry_element.find('line')
        if line_elem is not None:
            return self._generate_line_points_3d(start_pos, hdg, length, num_points)
        
        arc_elem = geometry_element.find('arc')
        if arc_elem is not None:
            curvature = float(arc_elem.get('curvature', 0))
            return self._generate_arc_points_3d(start_pos, hdg, curvature, length, num_points)
        
        spiral_elem = geometry_element.find('spiral')
        if spiral_elem is not None:
            curv_start = float(spiral_elem.get('curvStart', 0))
            curv_end = float(spiral_elem.get('curvEnd', 0))
            return self._generate_spiral_points_3d(start_pos, hdg, curv_start, curv_end, length, num_points)
        
        poly3_elem = geometry_element.find('poly3')
        if poly3_elem is not None:
            a = float(poly3_elem.get('a', 0))
            b = float(poly3_elem.get('b', 0))
            c = float(poly3_elem.get('c', 0))
            d = float(poly3_elem.get('d', 0))
            return self._generate_poly3_points_3d(start_pos, hdg, a, b, c, d, length, num_points)
        
        param_poly3_elem = geometry_element.find('paramPoly3')
        if param_poly3_elem is not None:
            au = float(param_poly3_elem.get('aU', 0))
            bu = float(param_poly3_elem.get('bU', 0))
            cu = float(param_poly3_elem.get('cU', 0))
            du = float(param_poly3_elem.get('dU', 0))
            av = float(param_poly3_elem.get('aV', 0))
            bv = float(param_poly3_elem.get('bV', 0))
            cv = float(param_poly3_elem.get('cV', 0))
            dv = float(param_poly3_elem.get('dV', 0))
            p_range = param_poly3_elem.get('pRange', 'arcLength')
            return self._generate_param_poly3_points_3d(start_pos, hdg, au, bu, cu, du, av, bv, cv, dv, length, num_points, p_range)
        
        # 默认返回直线
        return self._generate_line_points_3d(start_pos, hdg, length, num_points)
    
    def _generate_line_points_3d(self, start_pos: List[float], hdg: float, length: float, num_points: int) -> List[Vec3D]:
        """
        生成直线几何体的3D点
        
        Args:
            start_pos: 起始位置 [x, y]
            hdg: 航向角
            length: 长度
            num_points: 点数
            
        Returns:
            3D点列表
        """
        points = []
        
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            s = t * length
            
            x = start_pos[0] + s * math.cos(hdg)
            y = start_pos[1] + s * math.sin(hdg)
            z = 0.0  # 简化：假设平面道路
            
            points.append(Vec3D(x, y, z))
        
        return points
    
    def _generate_arc_points_3d(self, start_pos: List[float], hdg: float, curvature: float, 
                                length: float, num_points: int) -> List[Vec3D]:
        """
        生成圆弧几何体的3D点
        
        Args:
            start_pos: 起始位置 [x, y]
            hdg: 起始航向角
            curvature: 曲率
            length: 弧长
            num_points: 点数
            
        Returns:
            3D点列表
        """
        points = []
        
        if abs(curvature) < 1e-10:
            # 曲率接近0，当作直线处理
            return self._generate_line_points_3d(start_pos, hdg, length, num_points)
        
        radius = 1.0 / abs(curvature)
        
        # 计算圆心
        center_offset_x = -radius * math.sin(hdg) if curvature > 0 else radius * math.sin(hdg)
        center_offset_y = radius * math.cos(hdg) if curvature > 0 else -radius * math.cos(hdg)
        
        center_x = start_pos[0] + center_offset_x
        center_y = start_pos[1] + center_offset_y
        
        # 起始角度
        start_angle = hdg - math.pi/2 if curvature > 0 else hdg + math.pi/2
        
        # 角度变化
        total_angle = length * curvature
        
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            angle = start_angle + t * total_angle
            
            x = center_x + radius * math.cos(angle)
            y = center_y + radius * math.sin(angle)
            z = 0.0  # 简化：假设平面道路
            
            points.append(Vec3D(x, y, z))
        
        return points
    
    def _generate_spiral_points_3d(self, start_pos: List[float], hdg: float, curv_start: float, 
                                   curv_end: float, length: float, num_points: int) -> List[Vec3D]:
        """
        生成螺旋线几何体的3D点
        
        Args:
            start_pos: 起始位置 [x, y]
            hdg: 起始航向角
            curv_start: 起始曲率
            curv_end: 结束曲率
            length: 长度
            num_points: 点数
            
        Returns:
            3D点列表
        """
        points = []
        
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            s = t * length
            
            # 积分计算螺旋线
            dx, dy, dhdg = self._integrate_spiral(s, curv_start, curv_end, length)
            
            # 旋转到正确的方向
            cos_hdg = math.cos(hdg)
            sin_hdg = math.sin(hdg)
            
            x = start_pos[0] + dx * cos_hdg - dy * sin_hdg
            y = start_pos[1] + dx * sin_hdg + dy * cos_hdg
            z = 0.0  # 简化：假设平面道路
            
            points.append(Vec3D(x, y, z))
        
        return points
    
    def _integrate_spiral(self, s: float, curv_start: float, curv_end: float, length: float) -> Tuple[float, float, float]:
        """
        积分计算螺旋线参数
        
        Args:
            s: 当前弧长
            curv_start: 起始曲率
            curv_end: 结束曲率
            length: 总长度
            
        Returns:
            (dx, dy, dhdg) 相对位移和航向角变化
        """
        # 简化的螺旋线积分实现
        # 使用数值积分方法
        
        num_steps = max(10, int(s / 0.1))
        dx, dy, hdg = 0.0, 0.0, 0.0
        
        for i in range(num_steps):
            s_local = (i / num_steps) * s
            ds = s / num_steps
            
            # 线性插值曲率
            if length > 0:
                t_local = s_local / length
                curvature = curv_start + (curv_end - curv_start) * t_local
            else:
                curvature = curv_start
            
            # 更新航向角
            hdg += curvature * ds
            
            # 更新位置
            dx += math.cos(hdg) * ds
            dy += math.sin(hdg) * ds
        
        return dx, dy, hdg
    
    def _generate_poly3_points_3d(self, start_pos: List[float], hdg: float, a: float, b: float, 
                                  c: float, d: float, length: float, num_points: int) -> List[Vec3D]:
        """
        生成三次多项式几何体的3D点
        
        Args:
            start_pos: 起始位置 [x, y]
            hdg: 起始航向角
            a, b, c, d: 多项式系数
            length: 长度
            num_points: 点数
            
        Returns:
            3D点列表
        """
        points = []
        
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            s = t * length
            
            # 计算横向偏移
            lateral_offset = a + b * s + c * s * s + d * s * s * s
            
            # 计算位置
            cos_hdg = math.cos(hdg)
            sin_hdg = math.sin(hdg)
            
            x = start_pos[0] + s * cos_hdg - lateral_offset * sin_hdg
            y = start_pos[1] + s * sin_hdg + lateral_offset * cos_hdg
            z = 0.0  # 简化：假设平面道路
            
            points.append(Vec3D(x, y, z))
        
        return points
    
    def _generate_param_poly3_points_3d(self, start_pos: List[float], hdg: float, 
                                       au: float, bu: float, cu: float, du: float,
                                       av: float, bv: float, cv: float, dv: float,
                                       length: float, num_points: int, p_range: str = 'arcLength') -> List[Vec3D]:
        """
        生成参数三次多项式几何体的3D点
        
        Args:
            start_pos: 起始位置 [x, y]
            hdg: 起始航向角
            au, bu, cu, du: u方向多项式系数
            av, bv, cv, dv: v方向多项式系数
            length: 长度
            num_points: 点数
            p_range: 参数范围类型
            
        Returns:
            3D点列表
        """
        points = []
        
        for i in range(num_points):
            t = i / (num_points - 1) if num_points > 1 else 0
            
            if p_range == 'arcLength':
                p = t * length
            else:
                p = t
            
            # 计算参数坐标
            u = au + bu * p + cu * p * p + du * p * p * p
            v = av + bv * p + cv * p * p + dv * p * p * p
            
            # 转换到全局坐标
            cos_hdg = math.cos(hdg)
            sin_hdg = math.sin(hdg)
            
            x = start_pos[0] + u * cos_hdg - v * sin_hdg
            y = start_pos[1] + u * sin_hdg + v * cos_hdg
            z = 0.0  # 简化：假设平面道路
            
            points.append(Vec3D(x, y, z))
        
        return points
    
    def _export_materials(self, mtl_file: str, mesh: Mesh3D = None):
        """
        导出材质文件
        
        Args:
            mtl_file: MTL文件路径
            mesh: 网格对象，用于获取实际使用的材质
        """
        mtl_content = [
            "# Material file generated by XODR to OBJ Converter v3.1.0",
            "# Based on libOpenDRIVE implementation",
            ""
        ]
        
        # 基础材质
        base_materials = {
            "default_material": {
                "Ka": "0.2 0.2 0.2",
                "Kd": "0.6 0.6 0.6",
                "Ks": "0.1 0.1 0.1",
                "Ns": "10.0",
                "illum": "2"
            },
            "road_surface": {
                "Ka": "0.1 0.1 0.1",
                "Kd": "0.4 0.4 0.4",
                "Ks": "0.05 0.05 0.05",
                "Ns": "5.0",
                "illum": "2"
            },
            "lanes": {
                "Ka": "0.15 0.15 0.15",
                "Kd": "0.5 0.5 0.5",
                "Ks": "0.1 0.1 0.1",
                "Ns": "8.0",
                "illum": "2"
            }
        }
        
        # 获取网格中实际使用的材质
        used_materials = set()
        if mesh:
            used_materials = set(mesh.material_groups.keys())
        
        # 添加基础材质
        for mat_name, properties in base_materials.items():
            if not mesh or mat_name in used_materials:
                mtl_content.append(f"newmtl {mat_name}")
                for prop, value in properties.items():
                    mtl_content.append(f"{prop} {value}")
                mtl_content.append("")
        
        # 动态生成车道材质
        if mesh:
            for mat_name in used_materials:
                if mat_name.startswith('lane_'):
                    # 解析车道ID
                    if mat_name.startswith('lane_neg_'):
                        lane_id = -int(mat_name.replace('lane_neg_', ''))
                        # 右侧车道使用红色调
                        ka = "0.15 0.1 0.1"
                        kd = f"0.{6 + abs(lane_id)} 0.3 0.3"
                        ks = "0.1 0.05 0.05"
                    else:
                        lane_id = int(mat_name.replace('lane_', ''))
                        # 左侧车道使用绿色调
                        ka = "0.1 0.15 0.1"
                        kd = f"0.3 0.{6 + lane_id} 0.3"
                        ks = "0.05 0.1 0.05"
                    
                    mtl_content.extend([
                        f"newmtl {mat_name}",
                        f"Ka {ka}",
                        f"Kd {kd}",
                        f"Ks {ks}",
                        "Ns 8.0",
                        "illum 2",
                        ""
                    ])
        
        try:
            with open(mtl_file, 'w', encoding='utf-8') as f:
                f.write("\n".join(mtl_content))
        except Exception as e:
            if self.verbose:
                logger.error(f"导出材质文件失败: {str(e)}")


def convert_xodr_to_obj(xodr_file: str, obj_file: str, resolution: float = 0.5) -> bool:
    """
    转换XODR文件到OBJ格式的便捷函数
    
    Args:
        xodr_file: 输入XODR文件路径
        obj_file: 输出OBJ文件路径
        resolution: 采样分辨率（米）
        
    Returns:
        转换是否成功
    """
    converter = XODRToOBJConverter(resolution=resolution)
    converter.verbose = True
    return converter.convert(xodr_file, obj_file)


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 3:
        logger.info("用法: python xodr_to_obj_converter.py <input.xodr> <output.obj> [resolution]")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    resolution = float(sys.argv[3]) if len(sys.argv) > 3 else 1.0
    
    converter = XODRToOBJConverter(resolution=resolution, verbose=True)
    success = converter.convert(input_file, output_file)
    
    if success:
        logger.info("✅ 多车道OBJ转换成功！")
    else:
        logger.error("❌ 转换失败！")